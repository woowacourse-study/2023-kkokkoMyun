## 질문
ConcurrentHashMap에 대해 아는 만큼 설명해 봅시다.
### 개념 설명
ConcurrentHashMap은 JVM의 멀티 스레드 환경에서
HashMap을 동시성으로부터 안전하게 다루기 위해 사용합니다.
조금 더 정확히 정의하면,
HashMap의 성능을 유지하면서도
동시성에서 중요한 **가시성**과 **원자성**이 보장된 자료구조입니다.

## 꼬리 질문
### 꼬리 1 - 가시성과 원자성이란 무엇인가요?
### 답변
가시성: 단어의 뜻 그대로, 어떤 값을 있는 그대로 볼 수 있는 특성을 뜻합니다.
우리가 인프라에 캐싱을 도입할 때의 주의점으로 항상 이야기하는 '캐시 값과 실제 값의 차이' 라는 내용을 운영체제의 영역에서 다룬다고 생각하면 편해요.
우리가 어떤 코드를 작성할 때, 작성자의 입장에서는 코드를 작성한 **순서대로** 실행해 줄 것이라고 기대하지만
운영체제는 자신의 입장에서 더 수월하게 일할 수 있도록 해당 코드의 실행 순서를 바꾼다거나, 레지스터같은 장소에 캐싱해 사용하는 등의 최적화를 합니다.
문제는 이런 최적화로 인해, 우리가 읽으려는 값이 실제 최신 값이 아닌 캐싱된 다른 값이 될 수 있다는 것입니다.
이를 해결하려면, '이 A라는 값은 최적화도 하지 말고 캐싱도 하지 마. 무조건 있는 그대로 읽어 와' 라는 명시적인 설정이 필요합니다.
이 설정을 했을 때 **가시성이 보장된다**라고 할 수 있습니다.

원자성: '원자'라는 단어가 가진 의미처럼, '더 이상 쪼갤 수 없는 연산'을 의미합니다.
우리가 고수준 언어로 작성하는 거의 모든 코드는 저수준으로 컴파일해 보면 몇 단계로 더 쪼갤 수 있습니다.
보통 읽기-변경-쓰기 순서대로 진행되는 Read-Modify-Write 패턴으로 쪼개지는데,
만약 실행 중인 두 개의 스레드가 ReadA-ReadB-ModifyA-ModifyB-WriteA-WriteB 순서대로 실행된다면
우리가 기대했던 결과와 다른 값이 나오게 됩니다.
꼭 저수준 영역뿐만 아니라 고수준의 작업에서도 일어날 수 있는데,
검증-행동 순서로 동작하는 Check-And-Act 패턴의 코드에 두 스레드가 동시에 접근하면
CheckA-CheckB-ActA-ActB 순서로 동작하면서 같은 문제가 발생하게 됩니다.

이를 해결하기 위해서는 특정 시점에 단 하나의 스레드만 자원과 작업에 접근할 수 있도록 보장해야 합니다.
이를 잘 보장하는 경우 **원자성이 보장된다**라고 할 수 있습니다.

### 꼬리 2 - ConcurrentHashMap에서 가시성과 원자성은 어떻게 보장할 수 있나요?
### 답변
가시성이 필요한 필드에 volatile 키워드를 붙여 가시성을,
원자성이 필요한 작업에 CAS 연산을 하여 원자성을 보장합니다.

### 꼬리 3 - Volatile은 어떻게 가시성을 보장하나요? 그리고 CAS는 또 무엇이죠?
젠장 드럽게 질문만 많군 초능력 맛 좀 볼래?
면접관: 으허억... 흐어억!!

## 참고 자료 및 레퍼런스
https://blog.hexabrain.net/126
https://blog.hexabrain.net/375
https://blog.hexabrain.net/377
https://blog.hexabrain.net/401
https://blog.hexabrain.net/403
